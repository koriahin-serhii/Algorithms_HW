2. Решить задачу методом перебора (проверить все маршруты) становится невозможно при большом числе городов — даже суперкомпьютер будет считать вечность. Поэтому приходится использовать приближенные методы (эвристики), которые не всегда дают оптимальный ответ, но работают намного быстрее.

3. 
	task 1
	•	Внешний цикл i идет от 1 до n → O(n)
	•	Внутренний цикл j от 1 до n, но внутри есть BREAK — значит, он выполняется только 1 раз
	•	=> внутренний цикл выполняется по 1 разу на каждую итерацию внешнего цикла
	•	➤ Итого: O(n)

	task 2
	•	Внешний цикл i от n/2 до n → O(n)
	•	Внутренний цикл j удваивается каждый раз: j = 2, 4, 8, ..., n → O(log n)
	•	➤ Итого: O(n log n)

	task 3
	•	Внешний цикл i от 0 до n → n итераций
	•	Внутренний цикл j от n до i → примерно от n до 0 → количество итераций: сначала n, потом n-1, …, до 1
	•	Сумма итераций: n + (n-1) + ... + 1 = n(n+1)/2 → O(n²)
	•	➤ Итого: O(n²)

	task 4
	•	i делится на 2 каждый раз → логарифмическое количество итераций
	•	➤ Итого: O(log n)