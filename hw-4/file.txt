Решение 1: Слияние массивов (интуитивный подход)

function findKthElement(arr1, arr2, k) {
  let merged = [];
  let i = 0, j = 0;

  // Сливаем элементы из двух массивов, пока не получим k элементов
  while (merged.length < k) {
    if (i < arr1.length && (j >= arr2.length || arr1[i] < arr2[j])) {
      merged.push(arr1[i]);
      i++;
    } else {
      merged.push(arr2[j]);
      j++;
    }
  }

  return merged[k - 1]; // Индексация с 0, поэтому k-1
}

// Пример
const arr1 = [100, 112, 256, 349, 770];
const arr2 = [72, 86, 113, 119, 265, 445, 892];
const k = 7;

console.log(findKthElement(arr1, arr2, k));  // Вывод: 256





Решение 2: Эффективное (O(log k)) — через бинарный поиск

function findKthElementBinary(arr1, arr2, k) {
  // Убедимся, что arr1 всегда короче (для оптимизации бинарного поиска)
  if (arr1.length > arr2.length) {
    return findKthElementBinary(arr2, arr1, k);
  }

  let m = arr1.length;
  let n = arr2.length;

  let low = Math.max(0, k - n);
  let high = Math.min(k, m);

  while (low <= high) {
    let cut1 = Math.floor((low + high) / 2);
    let cut2 = k - cut1;

    let l1 = cut1 === 0 ? -Infinity : arr1[cut1 - 1];
    let l2 = cut2 === 0 ? -Infinity : arr2[cut2 - 1];
    let r1 = cut1 === m ? Infinity : arr1[cut1];
    let r2 = cut2 === n ? Infinity : arr2[cut2];

    if (l1 <= r2 && l2 <= r1) {
      return Math.max(l1, l2); // Это k-й элемент
    } else if (l1 > r2) {
      high = cut1 - 1;
    } else {
      low = cut1 + 1;
    }
  }

  return -1; // Ошибка (не должно произойти)
}